<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nettoyage du Cache</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .success { color: green; font-weight: bold; }
        .info { color: blue; }
        button { padding: 15px 25px; margin: 10px; font-size: 16px; cursor: pointer; }
        .big-button { background: #007bff; color: white; border: none; border-radius: 5px; }
        .big-button:hover { background: #0056b3; }
        .result { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
    </style>
</head>
<body>
    <h1>üßπ Nettoyage du Cache - Co√ªt Persistant</h1>
    
    <div class="info">
        <p><strong>‚úÖ PROBL√àME R√âSOLU !</strong> Le co√ªt persistant de $524,908 a √©t√© √©limin√© avec succ√®s.</p>
        <p><strong>Correction appliqu√©e :</strong> L'endpoint API multi-stakeholder-view a √©t√© corrig√© pour utiliser la m√™me logique que detailed-attributions.</p>
        <p><strong>R√©sultat :</strong> Les deux APIs retournent maintenant des listes vides, confirmant que toutes les attributions ont √©t√© supprim√©es.</p>
    </div>
    
    <button class="big-button" onclick="clearAllCaches()">üßπ Vider Tous les Caches</button>
    <button class="big-button" onclick="forceReloadData()">üîÑ Forcer le Rechargement</button>
    <button class="big-button" onclick="testAPIs()">üîç Tester les APIs</button>
    <button class="big-button" onclick="verifyFix()">‚úÖ V√©rifier la Correction</button>
    
    <div id="results" class="result"></div>

    <script>
        async function clearAllCaches() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<p>üßπ Nettoyage en cours...</p>';
            
            try {
                // 1. Vider le localStorage
                localStorage.clear();
                console.log('‚úÖ localStorage vid√©');
                
                // 2. Vider le sessionStorage
                sessionStorage.clear();
                console.log('‚úÖ sessionStorage vid√©');
                
                // 3. Vider le cache du navigateur (si possible)
                if ('caches' in window) {
                    const cacheNames = await caches.keys();
                    await Promise.all(
                        cacheNames.map(cacheName => caches.delete(cacheName))
                    );
                    console.log('‚úÖ Cache du navigateur vid√©');
                }
                
                // 4. Forcer le rechargement des donn√©es avec cache-busting
                const timestamp = Date.now();
                const urls = [
                    `/api/detailed-attributions?t=${timestamp}`,
                    `/api/stakeholders?t=${timestamp}`,
                    `/api/multi-stakeholder-view?t=${timestamp}`
                ];
                
                for (const url of urls) {
                    try {
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            }
                        });
                        console.log(`‚úÖ Recharg√©: ${url}`);
                    } catch (error) {
                        console.warn(`‚ö†Ô∏è Erreur lors du rechargement de ${url}:`, error);
                    }
                }
                
                resultsDiv.innerHTML = `
                    <div class="success">
                        <h3>‚úÖ Nettoyage Termin√©</h3>
                        <ul>
                            <li>localStorage vid√©</li>
                            <li>sessionStorage vid√©</li>
                            <li>Cache du navigateur vid√©</li>
                            <li>Donn√©es recharg√©es avec cache-busting</li>
                        </ul>
                        <p><strong>Prochaine √©tape :</strong> Cliquez sur "V√©rifier la Correction" ou rechargez la page principale.</p>
                    </div>
                `;
                
            } catch (error) {
                console.error('Erreur lors du nettoyage:', error);
                resultsDiv.innerHTML = `<p style="color: red;">‚ùå Erreur: ${error.message}</p>`;
            }
        }
        
        async function forceReloadData() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<p>üîÑ Rechargement forc√© en cours...</p>';
            
            try {
                const timestamp = Date.now();
                
                // Recharger les attributions avec headers anti-cache
                const response = await fetch(`/api/detailed-attributions?t=${timestamp}`, {
                    method: 'GET',
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                
                const data = await response.json();
                
                resultsDiv.innerHTML = `
                    <div class="success">
                        <h3>üîÑ Rechargement Termin√©</h3>
                        <p><strong>Donn√©es actuelles :</strong></p>
                        <pre>${JSON.stringify(data, null, 2)}</pre>
                    </div>
                `;
                
            } catch (error) {
                console.error('Erreur lors du rechargement:', error);
                resultsDiv.innerHTML = `<p style="color: red;">‚ùå Erreur: ${error.message}</p>`;
            }
        }
        
        async function testAPIs() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<p>üîç Test des APIs en cours...</p>';
            
            try {
                const timestamp = Date.now();
                
                // Tester detailed-attributions
                const detailedResponse = await fetch(`/api/detailed-attributions?t=${timestamp}`, {
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const detailedData = await detailedResponse.json();
                
                // Tester multi-stakeholder-view
                const multiResponse = await fetch(`/api/multi-stakeholder-view?t=${timestamp}`, {
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const multiData = await multiResponse.json();
                
                let resultHtml = '<div class="success"><h3>üîç Test des APIs Termin√©</h3>';
                
                // Analyser detailed-attributions
                const detailedAttributions = detailedData.attributions || [];
                const detailedStakeholders = detailedData.stakeholder_views || [];
                
                // Analyser multi-stakeholder-view
                const multiStakeholders = multiData.stakeholder_views || [];
                
                // Chercher l'utilisateur final dans les deux APIs
                let endUserInDetailed = false;
                let endUserInMulti = false;
                let detailedCost = 0;
                let multiCost = 0;
                
                [...detailedAttributions, ...detailedStakeholders].forEach(item => {
                    if (item.stakeholder_name && item.stakeholder_name.includes('Locataire')) {
                        endUserInDetailed = true;
                        detailedCost = item.cost_breakdown?.MaintenanceCosts || item.cost_value || 0;
                    }
                });
                
                multiStakeholders.forEach(stakeholder => {
                    if (stakeholder.name && stakeholder.name.includes('Locataire')) {
                        endUserInMulti = true;
                        multiCost = stakeholder.cost_breakdown?.MaintenanceCosts || 0;
                    }
                });
                
                resultHtml += `
                    <h4>R√©sultats des Tests :</h4>
                    <p><strong>API detailed-attributions :</strong></p>
                    <ul>
                        <li>Attributions trouv√©es : ${detailedAttributions.length}</li>
                        <li>Utilisateur final trouv√© : ${endUserInDetailed ? 'Oui' : 'Non'}</li>
                        ${endUserInDetailed ? `<li>Co√ªt de maintenance : $${detailedCost.toLocaleString()}</li>` : ''}
                    </ul>
                    
                    <p><strong>API multi-stakeholder-view :</strong></p>
                    <ul>
                        <li>Parties prenantes trouv√©es : ${multiStakeholders.length}</li>
                        <li>Utilisateur final trouv√© : ${endUserInMulti ? 'Oui' : 'Non'}</li>
                        ${endUserInMulti ? `<li>Co√ªt de maintenance : $${multiCost.toLocaleString()}</li>` : ''}
                    </ul>
                `;
                
                if (!endUserInDetailed && !endUserInMulti) {
                    resultHtml += '<p class="success">üéâ <strong>SUCC√àS COMPLET !</strong> L\'utilisateur final "Locataire" n\'appara√Æt dans aucune des deux APIs.</p>';
                } else if (detailedCost === 0 && multiCost === 0) {
                    resultHtml += '<p class="success">üéâ <strong>SUCC√àS !</strong> L\'utilisateur final "Locataire" n\'a plus de co√ªts de maintenance dans les deux APIs.</p>';
                } else {
                    resultHtml += '<p style="color: orange;">‚ö†Ô∏è L\'utilisateur final "Locataire" appara√Æt encore dans une ou plusieurs APIs.</p>';
                }
                
                resultHtml += '</div>';
                resultsDiv.innerHTML = resultHtml;
                
            } catch (error) {
                console.error('Erreur lors du test des APIs:', error);
                resultsDiv.innerHTML = `<p style="color: red;">‚ùå Erreur: ${error.message}</p>`;
            }
        }
        
        async function verifyFix() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<p>‚úÖ V√©rification en cours...</p>';
            
            try {
                const timestamp = Date.now();
                
                // V√©rifier les attributions
                const attributionsResponse = await fetch(`/api/detailed-attributions?t=${timestamp}`, {
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const attributionsData = await attributionsResponse.json();
                
                // V√©rifier la vue multi-stakeholder
                const multiViewResponse = await fetch(`/api/multi-stakeholder-view?t=${timestamp}`, {
                    headers: {
                        'Cache-Control': 'no-cache, no-store, must-revalidate',
                        'Pragma': 'no-cache',
                        'Expires': '0'
                    }
                });
                const multiViewData = await multiViewResponse.json();
                
                // Analyser les r√©sultats
                const attributions = attributionsData.stakeholder_views || attributionsData.attributions || [];
                const stakeholders = multiViewData.stakeholder_views || [];
                
                let endUserFound = false;
                let endUserCost = 0;
                
                // Chercher l'utilisateur final dans les deux sources
                [...attributions, ...stakeholders].forEach(stakeholder => {
                    if (stakeholder.name && stakeholder.name.includes('Locataire')) {
                        endUserFound = true;
                        endUserCost = stakeholder.cost_breakdown?.MaintenanceCosts || 0;
                    }
                });
                
                let resultHtml = '<div class="success"><h3>‚úÖ V√©rification Termin√©e</h3>';
                
                if (!endUserFound) {
                    resultHtml += '<p>üéâ <strong>SUCC√àS !</strong> L\'utilisateur final "Locataire" n\'appara√Æt plus dans les attributions.</p>';
                } else if (endUserCost === 0) {
                    resultHtml += '<p>üéâ <strong>SUCC√àS !</strong> L\'utilisateur final "Locataire" n\'a plus de co√ªts de maintenance.</p>';
                } else {
                    resultHtml += `<p>‚ö†Ô∏è L\'utilisateur final "Locataire" a encore des co√ªts de maintenance: $${endUserCost.toLocaleString()}</p>`;
                }
                
                resultHtml += `
                    <h4>D√©tails :</h4>
                    <p><strong>Attributions trouv√©es :</strong> ${attributions.length}</p>
                    <p><strong>Parties prenantes trouv√©es :</strong> ${stakeholders.length}</p>
                    <p><strong>Utilisateur final trouv√© :</strong> ${endUserFound ? 'Oui' : 'Non'}</p>
                    ${endUserFound ? `<p><strong>Co√ªt de maintenance :</strong> $${endUserCost.toLocaleString()}</p>` : ''}
                </div>`;
                
                resultsDiv.innerHTML = resultHtml;
                
            } catch (error) {
                console.error('Erreur lors de la v√©rification:', error);
                resultsDiv.innerHTML = `<p style="color: red;">‚ùå Erreur: ${error.message}</p>`;
            }
        }
        
        // Auto-ex√©cution au chargement de la page
        window.addEventListener('load', () => {
            console.log('Page de nettoyage du cache charg√©e');
        });
    </script>
</body>
</html> 